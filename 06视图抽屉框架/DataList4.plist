<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>title</key>
		<string>sip是什么？</string>
		<key>detail</key>
		<string>	&lt;p&gt;•	SIP（Session Initiation Protocol），会话发起协议&lt;br/&gt;•	SIP是建立VOIP连接的 IETF 标准，IETF是全球互联网最具权威的技术标准化组织&lt;br/&gt;•	所谓VOIP，就是网络电话，直接用互联网打电话，不用耗手机话费&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>json解析的具体实现</string>
		<key>detail</key>
		<string>&lt;p&gt;	•	SBJson&lt;br/&gt;•	JSONKit&lt;br/&gt;•	NSJSONSerialization&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>地图导航不能用了怎么办</string>
		<key>detail</key>
		<string>&lt;p&gt;提示用户打开导航定位功能 &lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>你在实际开发中，有哪些手机架构与性能调试经验</string>
		<key>detail</key>
		<string>&lt;p&gt;	•	刚接手公司的旧项目时，模块特别多，而且几乎所有的代码都写在控制器里面，比如UI控件代码、网络请求代码、数据存储代码&lt;br/&gt;•	接下来采取MVC模式进行封装、重构&lt;br/&gt;•	自定义UI控件封装内部的业务逻辑&lt;br/&gt;•	封装网络请求工具类(降低耦合)&lt;br/&gt;•	封装数据存储工具类&lt;/p&gt;
</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>列举现在熟悉iOS开发库和第三方开发库？</string>
		<key>detail</key>
		<string>&lt;p&gt;友盟，高德地图，百度地图,AFN,SDWebimage,FMDB, MBProgressHUD等等&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>第三方API是怎么用的？</string>
		<key>detail</key>
		<string>&lt;p&gt;	•	大公司的开放API&lt;br/&gt;•	github上面别人发布的框架&lt;br/&gt;•	第三方API在官方文档都有说明，按照官方文档的一步一步做&lt;br/&gt;•	参考官方提供的示例程序&lt;br/&gt;•	先自己创建一个工程试试，等熟悉了，在使用到项目中&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>把程序自己关掉和程序进入后台,远程推送的区别</string>
		<key>detail</key>
		<string>&lt;p&gt;1. 关掉后不执行任何代码, 不能处理事件&lt;br/&gt;2. 应用程序进入后台状态不久后转入挂起状态。在这种状态下，应用程序不执行任何代码，并有可能在任意时候从内存中删除。只有当用户再次运行此应用，应用才会从挂起状态唤醒，代码得以继续执行&lt;br/&gt;3.或者进入后台时开启多任务状态，保留在内存中，这样就可以执行系统允许的动作&lt;br/&gt;4.远程推送是由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序,当应用程序收到推送的消息会自动调用特定的方法执行事先写好的代码&lt;/p&gt;</string>
		<key>itemType</key>
		<string>5</string>
		<key>zan</key>
		<integer>6</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>本地通知和远程推送通知对基本概念和用法？</string>
		<key>detail</key>
		<string>&lt;p&gt;	本地通知和远程推送通知都可以向不在前台运行的应用发送消息,这种消息既可能是即将发生的事件,也可能是服务器的新数据.不管是本地通知还是远程通知,他们在程序界面的显示效果相同,都可能显示为一段警告信息或应用程序图标上的微章.&lt;br/&gt;本地通知和远程推送通知的基本目的都是让应用程序能够通知用户某些事情, 而且不需要应用程序在前台运行.二者的区别在于本地通知由本应用负责调用,只能从当前设备上的iOS发出, 而远程通知由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>6</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>IOS平台怎么做数据的持久化.coredata和sqlite有无必然联系?coredata是一个关系型数据库吗?</string>
		<key>detail</key>
		<string>&lt;p&gt;	IOS中有4种持久化数据的方式:属性列表,对象归档SQLite3和core data.&lt;br/&gt;Core Data不是一个关系型数据库.&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>如果后期需要增加数据库中的字段怎么实&lt;br/&gt;现，如果不使用CoreData呢？</string>
		<key>detail</key>
		<string>&lt;p&gt;编写SQL语句来操作原来表中的字段•	增加表字段&lt;br/&gt;ALTER TABLE 表名 ADD COLUMN 字段名 字段类型;&lt;br/&gt;•	删除表字段&lt;br/&gt;ALTER TABLE 表名 DROP COLUMN 字段名;&lt;br/&gt;•	修改表字段&lt;br/&gt;ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名;&lt;br/&gt;例如: CREATE TABLE IF NOT_EXISTS t_person(id INTEGER , name TEXT , no TEXT);&lt;br/&gt;增加表字段 ALTER TABLE t_person ADD COLUMN score TEXT;&lt;br/&gt;删除表字段 ALTER TABLE t_person DROP COLUMN no;&lt;br/&gt;修改表字段 ALTER TABLE t_person RENAME COLUMN name TO title;&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>SQLite数据存储是怎么用？</string>
		<key>detail</key>
		<string>&lt;p&gt;	•	添加SQLite动态库：&lt;br/&gt;•	导入主头文件：#import &lt;sqlite3.h&gt;&lt;br/&gt;•	利用C语言函数创建\打开数据库，编写SQL语句&lt;/p&gt;
</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>mvc设计模式是什么？ 你还熟悉什么设计模式？</string>
		<key>detail</key>
		<string>&lt;p&gt;设计模式：并不是一种新技术，而是一种编码经验，使用比如java中的接口，iphone中的协议，继承关系等基本手段，&lt;br/&gt;用比较成熟的逻辑去处理某一种类型的事情，总结为所谓设计模式。面向对象编程中，java已经归纳了23中设计模式。&lt;br/&gt;&lt;br/&gt;mvc设计模式 ，模型，视图，控制器，可以将整个应用程序在思想上分成三大块，对应是的数据的存储或处理，前台的显示，业务逻辑的控制。 Iphone本身的设计思想就是遵循mvc设计模式。其不属于23中设计模式范畴。&lt;br/&gt;&lt;br/&gt;代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用.比如一个工厂生产了产品，并不想直接卖给用户，而是搞了很多代理商，用户可以直接找代理商买东西，代理商从工厂进货.&lt;br/&gt;常见的如QQ的自动回复就属于代理拦截，代理模式在iphone中得到广泛应用.&lt;br/&gt;&lt;br/&gt;单例模式：说白了就是一个类不通过alloc方式创建对象，而是用一个静态方法返回这个类的对象。系统只需要拥有一个的全局对象，&lt;br/&gt;这样有利于我们协调系统整体的行为，比如想获得[UIApplication sharedApplication];任何地方调用都可以得到 UIApplication的对象，这个对象是全局唯一的。&lt;br/&gt;&lt;br/&gt;观察者模式： 当一个物体发生变化时，会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的对象给这个物体，当这个物体的发生改变，就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>http和scoket通信的区别。</string>
		<key>detail</key>
		<string>&lt;p&gt;http是客户端用http协议进行请求，发送请求时候需要封装http请求头，并绑定请求的数据，服务器一般有web服务器配合（当然也非绝对）。 http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接技术）。iphone主要使用类是NSUrlConnection。&lt;br/&gt; scoket是客户端跟服务器直接使用socket“套接字”进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或股票开发这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是CFSocketRef。&lt;/p&gt;
</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>7</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>如果后期需要增加数据库中的字段怎么实现，如果不使用CoreData呢？</string>
		<key>detail</key>
		<string>&lt;p&gt;编写SQL语句来操作原来表中的字段&lt;br/&gt;•	增加表字段&lt;br/&gt;ALTER TABLE 表名 ADD COLUMN 字段名 字段类型;&lt;br/&gt;•	删除表字段&lt;br/&gt;ALTER TABLE 表名 DROP COLUMN 字段名;&lt;br/&gt;•	修改表字段&lt;br/&gt;ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名;&lt;br/&gt;例如: CREATE TABLE IF NOT_EXISTS t_person(id INTEGER , name TEXT , no TEXT);&lt;br/&gt;增加表字段 ALTER TABLE t_person ADD COLUMN score TEXT;&lt;br/&gt;删除表字段 ALTER TABLE t_person DROP COLUMN no;&lt;br/&gt;修改表字段 ALTER TABLE t_person RENAME COLUMN name TO title;&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>使用SVN中应该注意什么.</string>
		<key>detail</key>
		<string>&lt;p&gt;	1.先更新再提交&lt;br/&gt;2.最好不要多人同时修改一个storyboad.(尽量不要用SVN来管理SB);&lt;br/&gt;3.最好不要多人同时修改同一个文件,防止代码冲突.&lt;/p&gt;
</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>4</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>MD5加密算法</string>
		<key>detail</key>
		<string>&lt;p&gt;	MD5针对同一个字符串加密得到的结果是想同的.(32个字符)&lt;br/&gt;算法的源程序是开源的.&lt;br/&gt;加&quot;盐&quot;保证密码安全,(拼接一个超级长的字符串)&lt;/p&gt;
</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>4</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>coredata有哪几种持久化存储机制？</string>
		<key>detail</key>
		<string>&lt;p&gt;答案：coredatat提供以下几种存储机制：XML（iOS系统不支持）,自动存储,SQLite,内存存储。 &lt;br/&gt;补充说明：这个问题问的是，coredate框架的存储机制，平时使用coredata时，更多关注的是managed的对象，这里是coerdata框架的存储实现细节。BTW: 其他常用的持久化存储方法 ：存入到文件、 存入到NSUserDefaults（系统plist文件中）。&lt;/p&gt;
</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>什么是谓词？</string>
		<key>detail</key>
		<string>&lt;p&gt;答案：谓词是通过NSPredicate，是通过给定的逻辑条件作为约束条件，完成对数据的筛选。&lt;/p&gt;是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。&lt;p&gt;CoreText可以解决复杂文字内容排版问题。CoreImage可以处理图片，为其添加各种效果。体验是很强大，挺复杂的。&lt;/p&gt;
</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</string>
		<key>detail</key>
		<string>&lt;p&gt;抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一个文件解压压缩框架，从使用者的角度出发，只需关注发送给框架一个解压请求，框架完成复杂文 件的解压操作，并且在适当的时候通知给是哦难过者，如解压完成、解压出错等。在框架内部去构建对象的关系，通过抽象让其更为健壮、便于更改。其次是API 的说明文档。  &lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>7</integer>
	</dict>
	<dict>
		<key>title</key>
		<string> 对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？</string>
		<key>detail</key>
		<string>&lt;p&gt;最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用link命令及flag解决冲突。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>8</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>单件实例是什么</string>
		<key>detail</key>
		<string>&lt;p&gt;Foundation和Application Kit 框架中的一些类只允许创建单件对象，即这些类在当前进程中的唯一实例。举例来说，NSFileManager和NSWorkspace 类在使用时都是基于进程进行单件对象的实例化。当向这些类请求实例的时候，它们会向您传递单一实例的一个引用，如果该实例还不存在，则首先进行实例的分配和初始化。 单件对象充当控制中心的角色，负责指引或协调类的各种服务。如果类在概念上只有一个实例（比如NSWorkspace），就应该产生一个单件实例，而不是多个实例；如果将来某一天可能有多个实例，您可 以使用单件实例机制，而不是工厂方法或函数。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>2</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>什么是TCP连接的三次握手</string>
		<key>detail</key>
		<string>&lt;p&gt;第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；&lt;br/&gt;第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；&lt;br/&gt;第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。&lt;br/&gt;握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>5</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>socket连接和http连接的区别</string>
		<key>detail</key>
		<string>&lt;p&gt;http连接：http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉；&lt;br/&gt;
socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据的传输，那么为了维持连接需要发送心跳消息~~具体心跳消息格式是开发者自己定义的&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>6</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>利用Socket建立网络连接的步骤</string>
		<key>detail</key>
		<string>&lt;p&gt;建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。&lt;br/&gt;套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。&lt;br/&gt;1。服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。&lt;br/&gt;2。客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。&lt;br/&gt;3。连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>6</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between shallow copy and deep copy?</string>
		<key>detail</key>
		<string>&lt;p&gt;浅复制和深复制的区别？&lt;p&gt;&lt;p&gt;答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。 &lt;br/&gt;深层复制：复制引用对象本身。
用网上一哥们通俗的话将就是：  浅复制好比你和你的影子，你完蛋，你的影子也完蛋 &lt;br/&gt;深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is advantage of categories? What is difference between implementing a category and inheritance?</string>
		<key>detail</key>
		<string>&lt;p&gt;类别的作用？继承和类别在实现中有何区别？&lt;/p&gt;&lt;p&gt;答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。  类别主要有3个作用：&lt;br/&gt;(1)将类的实现分散到多个不同文件或多个不同框架中。&lt;br/&gt;(2)创建对私有方法的前向引用。&lt;br/&gt;(3)向对象添加非正式协议。   继承可以增加，修改或者删除方法，并且可以增加属性。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between categories and extensions?</string>
		<key>detail</key>
		<string>  &lt;p&gt;类别和类扩展的区别&lt;/p&gt;&lt;p&gt;category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必要实现的。&lt;br/&gt;extensions可以认为是一个私有的Category。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between protocol in objective c and interfaces in java?</string>
		<key>detail</key>
		<string>&lt;p&gt;oc中的协议和java中的接口概念有何不同？&lt;/p&gt;&lt;p&gt;答案：OC中的代理有2层含义，官方定义为 formal和informal protocol。&lt;br/&gt;前者和Java接口一样。  informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。 &lt;br/&gt;&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is purpose of delegates?</string>
		<key>detail</key>
		<string>&lt;p&gt;代理的作用？&lt;/p&gt;&lt;p&gt;答案：代理的目的是改变或传递控制链。&lt;br/&gt;允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。&lt;br/&gt;可以减少框架复杂度。另外一点，代理可以理解为java中的回调监听机制的一种类似。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What are mutable and immutable types in Objective C?</string>
		<key>detail</key>
		<string>&lt;p&gt;oc中可修改和不可以修改类型。 &lt;br/&gt;&lt;br/&gt; 答案：可修改不可修改的集合类。&lt;br/&gt;这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。 &lt;br/&gt; 比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>When we call objective c is runtime language what does it mean?</string>
		<key>detail</key>
		<string>&lt;p&gt;我们说的oc是动态运行时语言是什么意思？&lt;/p&gt;&lt;p&gt;答案：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。&lt;br/&gt;  简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。  &lt;br/&gt;多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;  那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。 &lt;br/&gt; 也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。&lt;br/&gt; 因此也可以说，运行时机制是多态的基础？~~~&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>what is difference between NSNotification and protocol?</string>
		<key>detail</key>
		<string>&lt;p&gt;通知和协议的不同之处？  &lt;br/&gt;&lt;br/&gt;答案：协议有控制链(has-a)的关系，通知没有。&lt;br/&gt;  首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解  简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。  代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。  只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的  发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is push notification?</string>
		<key>detail</key>
		<string>&lt;p&gt;  推送通知更是一种技术。&lt;br/&gt;&lt;br/&gt;  简单点就是客户端获取资源的一种手段。 &lt;br/&gt;普通情况下，都是客户端主动的pull。推送则是服务器端主动push。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>what is Polymorphism？</string>
		<key>detail</key>
		<string>&lt;p&gt;关于多态性  &lt;br/&gt;答案：多态，子类指针可以赋值给父类。&lt;br/&gt; 这个题目其实可以出到一切面向对象语言中，  因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来。  最重要的是转化成自我理解。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is responder chain?</string>
		<key>detail</key>
		<string>&lt;p&gt;说说响应链  &lt;br/&gt;&lt;br/&gt;答案： 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。 &lt;br/&gt; 可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。&lt;br/&gt;因为问的太抽象化了  严重怀疑题目出到越后面就越笼统。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between frame and bounds?</string>
		<key>detail</key>
		<string>&lt;p&gt;frame和bounds有什么不同？ &lt;br/&gt;&lt;br/&gt; 答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统） &lt;br/&gt; bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Is there any garbage collection mechanism in Objective C.?</string>
		<key>detail</key>
		<string>&lt;p&gt; OC的垃圾回收机制？&lt;br/&gt;  答案： OC2.0有Garbage collection，但是iOS平台不提供。&lt;br/&gt;  一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。&lt;br/&gt; 但是差了大部分资料，貌似不要和arc机制搞混就好了。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between method and selector?</string>
		<key>detail</key>
		<string>&lt;p&gt;方法和选择器有何不同？  &lt;br/&gt;答案：selector是一个方法的名字，method是一个组合体，包含了名字和实现. &lt;br/&gt;详情可以看apple文档。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>NSOperation queue?</string>
		<key>detail</key>
		<string>&lt;p&gt;答案：存放NSOperation的集合类。 &lt;br/&gt;&lt;br/&gt; 操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。 &lt;br/&gt; 网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。 &lt;br/&gt;&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is lazy loading?</string>
		<key>detail</key>
		<string>&lt;p&gt;答案：懒汉模式，只在用到的时候才去初始化。&lt;br/&gt; 也可以理解成延时加载。  &lt;br/&gt;我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Can we use one tableview with two different datasources? How you will achieve this?</string>
		<key>detail</key>
		<string>&lt;p&gt;一个tableView是否可以关联两个不同的数据源？你会怎么处理？&lt;/p&gt;&lt;p&gt;  答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。 &lt;br/&gt; 因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。  因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
</array>
</plist>
