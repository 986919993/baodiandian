<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>title</key>
		<string>Difference between shallow copy and deep copy?</string>
		<key>detail</key>
		<string>&lt;p&gt;浅复制和深复制的区别？&lt;p&gt;&lt;p&gt;答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。 &lt;br/&gt;深层复制：复制引用对象本身。
用网上一哥们通俗的话将就是：  浅复制好比你和你的影子，你完蛋，你的影子也完蛋 &lt;br/&gt;深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is advantage of categories? What is difference between implementing a category and inheritance?</string>
		<key>detail</key>
		<string>&lt;p&gt;类别的作用？继承和类别在实现中有何区别？&lt;/p&gt;&lt;p&gt;答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。  类别主要有3个作用：&lt;br/&gt;(1)将类的实现分散到多个不同文件或多个不同框架中。&lt;br/&gt;(2)创建对私有方法的前向引用。&lt;br/&gt;(3)向对象添加非正式协议。   继承可以增加，修改或者删除方法，并且可以增加属性。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between categories and extensions?</string>
		<key>detail</key>
		<string>  &lt;p&gt;类别和类扩展的区别&lt;/p&gt;&lt;p&gt;category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必要实现的。&lt;br/&gt;extensions可以认为是一个私有的Category。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between protocol in objective c and interfaces in java?</string>
		<key>detail</key>
		<string>&lt;p&gt;oc中的协议和java中的接口概念有何不同？&lt;/p&gt;&lt;p&gt;答案：OC中的代理有2层含义，官方定义为 formal和informal protocol。&lt;br/&gt;前者和Java接口一样。  informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。 &lt;br/&gt;&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is purpose of delegates?</string>
		<key>detail</key>
		<string>&lt;p&gt;代理的作用？&lt;/p&gt;&lt;p&gt;答案：代理的目的是改变或传递控制链。&lt;br/&gt;允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。&lt;br/&gt;可以减少框架复杂度。另外一点，代理可以理解为java中的回调监听机制的一种类似。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What are mutable and immutable types in Objective C?</string>
		<key>detail</key>
		<string>&lt;p&gt;oc中可修改和不可以修改类型。 &lt;br/&gt;&lt;br/&gt; 答案：可修改不可修改的集合类。&lt;br/&gt;这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。 &lt;br/&gt; 比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>When we call objective c is runtime language what does it mean?</string>
		<key>detail</key>
		<string>&lt;p&gt;我们说的oc是动态运行时语言是什么意思？&lt;/p&gt;&lt;p&gt;答案：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。&lt;br/&gt;  简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。  &lt;br/&gt;多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;  那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。 &lt;br/&gt; 也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。&lt;br/&gt; 因此也可以说，运行时机制是多态的基础？~~~&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>what is difference between NSNotification and protocol?</string>
		<key>detail</key>
		<string>&lt;p&gt;通知和协议的不同之处？  &lt;br/&gt;&lt;br/&gt;答案：协议有控制链(has-a)的关系，通知没有。&lt;br/&gt;  首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解  简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。  代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。  只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的  发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is push notification?</string>
		<key>detail</key>
		<string>&lt;p&gt;  推送通知更是一种技术。&lt;br/&gt;&lt;br/&gt;  简单点就是客户端获取资源的一种手段。 &lt;br/&gt;普通情况下，都是客户端主动的pull。推送则是服务器端主动push。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>what is Polymorphism？</string>
		<key>detail</key>
		<string>&lt;p&gt;关于多态性  &lt;br/&gt;答案：多态，子类指针可以赋值给父类。&lt;br/&gt; 这个题目其实可以出到一切面向对象语言中，  因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来。  最重要的是转化成自我理解。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is responder chain?</string>
		<key>detail</key>
		<string>&lt;p&gt;说说响应链  &lt;br/&gt;&lt;br/&gt;答案： 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。 &lt;br/&gt; 可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。&lt;br/&gt;因为问的太抽象化了  严重怀疑题目出到越后面就越笼统。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between frame and bounds?</string>
		<key>detail</key>
		<string>&lt;p&gt;frame和bounds有什么不同？ &lt;br/&gt;&lt;br/&gt; 答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统） &lt;br/&gt; bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Difference between method and selector?</string>
		<key>detail</key>
		<string>&lt;p&gt;方法和选择器有何不同？  &lt;br/&gt;答案：selector是一个方法的名字，method是一个组合体，包含了名字和实现. &lt;br/&gt;详情可以看apple文档。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Is there any garbage collection mechanism in Objective C.?</string>
		<key>detail</key>
		<string>&lt;p&gt; OC的垃圾回收机制？&lt;br/&gt;  答案： OC2.0有Garbage collection，但是iOS平台不提供。&lt;br/&gt;  一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。&lt;br/&gt; 但是差了大部分资料，貌似不要和arc机制搞混就好了。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>NSOperation queue?</string>
		<key>detail</key>
		<string>&lt;p&gt;答案：存放NSOperation的集合类。 &lt;br/&gt;&lt;br/&gt; 操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。 &lt;br/&gt; 网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。 &lt;br/&gt;&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>What is lazy loading?</string>
		<key>detail</key>
		<string>&lt;p&gt;答案：懒汉模式，只在用到的时候才去初始化。&lt;br/&gt; 也可以理解成延时加载。  &lt;br/&gt;我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
	<dict>
		<key>title</key>
		<string>Can we use one tableview with two different datasources? How you will achieve this?</string>
		<key>detail</key>
		<string>&lt;p&gt;一个tableView是否可以关联两个不同的数据源？你会怎么处理？&lt;/p&gt;&lt;p&gt;  答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。 &lt;br/&gt; 因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。  因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？&lt;/p&gt;</string>
		<key>itemType</key>
		<string>4</string>
		<key>zan</key>
		<integer>1</integer>
	</dict>
</array>
</plist>
